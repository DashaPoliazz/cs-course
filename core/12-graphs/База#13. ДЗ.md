# ДЗ к лекции База#13

## Реализовать класс для представления графа с помощью матрицы смежности

Матрица должна быть реализована на основе типизированного массива.
Граф может быть ориентированным и неориентированным.
В значении ячейки матрицы можно хранить "вес" ребра или дуги.

```
class adjacencyMatrix = new Matrix(Uint8Array, 10, 10);

// Заполняем матрицу смежности
// ...

const graph = new Graph(adjacencyMatrix);

// Проверяем смежность двух узлов графа (с учетом направленности)
graph.checkAdjacency(1, 2);

// Добавляет ребро между двумя узлами и, опционально, вес.
// Если дуга уже есть, то просто меняется вес (если она задан).
graph.createEdge(7, 2, weight);

graph.removeEdge(7, 2);

// Добавляет дугу между двумя узлами и, опционально, вес
graph.createArc(7, 2, weight);

graph.removeArc(7, 2);
```

## Реализовать метод traverse для обхода смежных узлов графа начиная с заданного

Можно использовать обход в глубину.
Уже один раз пройденные узлы нужно игнорировать.

```
class adjacencyMatrix = new Matrix(Uint8Array, 10, 10);

// Заполняем матрицу смежности
// ...

const graph = new Graph(adjacencyMatrix);

graph.traverse(1, (node) => {
  // Номер узла
  console.log(node.id);

  // Вес ребра или дуги
  console.log(node.weight);
});
```

## Визуализировать созданный граф

Можно использовать библиотеку https://github.com/glejeune/node-graphviz.

## Создать транзитивное замыкание на основе заданного графа*

Опциональное задание для самых смелых.
